//
// Created by admin on 2023/2/26.
//

#include <iostream> //引入标准输入/输出流
#include <string> //引入字符串

//using namespace std; //使用命名空间std
using std::cin;
using std::cout;
using std::string;
using std::endl;

#include "L1_简介.h"


void function_in_out();

void const_cast_demo();

void default_params_demo(int, int, int);

void const_and_normal_ref();

void ref_init_demo();

void SwapValue(int, int);

void SwapRef(int &, int &);

void SwapTest();

int &RefValueFunc(int &x);

void RefValueFuncTest();

void const_and_zhizhen_demo();

void getArraySize();

void stringOp();

void stringMemberFunc();

void stringMemberFunc2();

void test();

void testArray();

int main() {
//    function_in_out();
//    const_cast_demo();
//    default_params_demo(1,2,3);
//    const_and_normal_ref();
//    ref_init_demo();
//    SwapTest();
//    RefValueFuncTest();
//    const_and_zhizhen_demo();
//    getArraySize();
//    stringOp();
//    stringMemberFunc2();

    testArray();
    return 0;
}

/*
 * Target
 * 1.了解C++发展历史，了解C++与C之间的异同点；
 * 2.掌握C++程序结构，能够正确使用头文件及命名空间；
 * 3.掌握C++基本输入/输出语句，实现程序的输入/输出工呢；
 * 4.掌握函数的声明，参数传递方式，参数默认值，内敛函数等相关知识，并灵活运用；
 * 5.理解函数重载的概念，能够根据调用语句识别出调用的函数版本；
 * 6.理解const含义及作用，理解指针及引用的概念；掌握C++中动态内存分配及释放的方法，并灵活运用；
 * 7.掌握string类的基本功能，能够声明string类对象，能够调用string类中成员函数进行基本操作；
 *
 *
 * --------------------------------------------------------------------------------------------------
 *
 * Section 1 C++语言的发展
 *
 * 通常根据是否可以直接操作计算机底层硬件，将程序设计语言分为低级语音、中级语言和高级语言；
 * 机器语言和汇编语言属于低级语言，因为它们能够直接操作计算机的寄存器和内存；
 * 机器语言是一种依赖于CPU的指令系统，使用机器指令的二进制代码编写程序，能够直接被计算机识别；
 * 汇编语言使用能够代表指令的助记符来编写程序，可以看作是符号化了的机器语音；
 * 这类语言会因为计算机指令系统的不同而不同，通用型差；
 * 在计算机诞生初期，使用低级语言编程是主要的开发形式；
 *
 * 高级语言是面相用户的语言，很多语言在形式上接近于算术语言和自然语言，程序员编写方便；
 * 使用高级语言编写的程序易读且通用型强，但大部分不能直接与硬件打交道，也不能直接在计算机上运行，需要系统软件支持，
 * 如需要编译程序及链接程序将高级语音编译链接为机器指令后才能运行；
 * 第一代高级语音以Fortran和ALGOL60语音为代表，它们的出现使得程序设计的难度降低，计算机应用的领域得到扩展，C++也属高级程序设计语音；
 *
 * C语言既有高级语音的形式，也能在一定程度上以特定的方法直接操作硬件；
 * 有些教材认为C语音为中级语言，还有一些将C语音视为高级程序设计语言；
 *
 * C++语音由Bjarne Stroustrup于1979年在美国贝尔实验室开始设计开发的；
 * 1985年，推出C++1.0版本；
 * 1989年和1993年增加了很多新功能的C++2.0及C++3.0版相继问世；
 * 1998年，C++的ANSI/ISO标准被投入使用，这是C++标准第一版，称为C++98；
 * 通常，C++98被认为是标准C++，所有主流C++编译器都支持这个版本；
 * C++标准第二版、第三版、第四版、第五版分别于2003、2011、2014、2017年发布；
 * 这四个标准分别称为c++03、C++11、C++14、C++17，都是目前C++编程语言的正式标准；
 *
 * C语音是C++语音的前身，C++语音最初被命名为带类的C语言，可见俩者之间的渊源；
 * 直到1983年才更名为C++语言；
 * 可以将C++语言看作C语言的一个超集，C语言中的绝大部分语法成分都被保留了下来，其实标准的C程序也可以在C++语音的开发环境下运行；
 *
 * Section 2 C++语言的特点
 *
 * C++语言是一种编译式的、通用的、大小写敏感的编程语言，完成支持面相对象的开发模式；
 * C++语言的主要特点表现在俩个方面：首先，它是C语言的继承，尽量兼容C语言，既保持了C语言的简洁和高效，可以像C语言那样进行结构化程序设计，
 * 同时也增强了C语言对类型的处理。其次加入了面相对象的特征，可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为
 * 特点的面相对象的程序设计；
 *
 * 从程序运行的稳定性来说，C++语言比C语言更安全，它支持过程化编程、面相对象编程和泛型编程；因为支持面相对象的开发模式，所以C++语言应用
 * 领域更加广泛；
 *
 * C++语言可以运行于多种平台上，如Windows、MAC操作系统以及UNIX的多种版本；
 *
 * C++语言加入面相对象的概念，虽然C语言的语法绝大部分都被保留，但C++的程序结构与C语言的程序结构存在很大差别；
 *
 * 一、基本的输入/输出
 * 在C语言中，标准的键盘输入和屏幕输出功能分别为scanf()和printf()；
 * 在C++语言中，类库中提供了输入流istream和输出流ostream；
 * cin和cout分别是istream和ostream类的对象，用来实现基本的键盘输入和屏幕输出；
 *
 * 在输入流中获取数据的操作称为提取操作，向输出流中添加数据的操作称为插入操作；
 * 运算符">>"和"<<"是位移运算符，在C++类库提供的头文件中已经对">>"和"<<"进行了重载，使之分别作为流提取运算符和流插入运算符，
 * 用来输入和输出C++标准类型的数据；
 *
 * 在C++中，可以使用流提取符">>"从标准输入设备键盘取得数据。例如，"cin>>x;"从键盘获取输入数据并赋值给x；
 * 使用cin可以活的多个来自键盘的输入值；
 * cout是标准输出流对象，使用流插入运算符"<<"向输出设备屏幕输出信息；
 * 当程序中用到cin和cout时，需要在程序中包含头文件<iostream>；
 * 用户自定义的类型的数据，不能直接使用">>"和"<<"进行输入/输出，必须对">>"和"<<"进行运算符重载才可使用；
 * cin的一般格式如下：
 * cin>>变量1>>变量2>>..>>变量n;
 * cout的一般格式如下：
 * cout<<表达式1<<表达式2<<...<<表达式n;
 * 其中，cin变量可以是任何基本类型的变量，当连续输入时，以空格、制表符(tab)、或Enter作为分隔符；
 * 当第一个字符是空格、tab或enter时，cin会忽略并清除掉，继续读取下一个字符；
 * cout语句中可以是各种基本类型的变量、常量、以及组合得到的正确表达式；
 *
 * 输入/输出示例 见function_in_out();
 */

void function_in_out() {
    int oneInt1, oneInt2;
    char strArray[20];
    string str;
    double oneDouble;
    char oneChar = 'a';

    cout << "输入俩个整型值，一个字符，一个字符串，和一个浮点数，";
    cout << "以空格、tab货enter分隔;" << endl;
    cin >> oneInt1 >> oneInt2 >> oneChar >> strArray >> oneDouble;
    str = strArray;
    cout << "输入的数据是:" << endl; //endl的作用是换行
    cout << "字符串是: \t\t" << str << endl //\t是制表符
         << "俩个整型值是: \t" << oneInt1 << " 和 " << oneInt2 << endl
         << "字符是: \t\t\t" << oneChar << "\n" //\n是换行符，与endl效果相同
         << "浮点值是: \t\t" << oneDouble << endl;
}

/*
* 二、头文件和命名空间
* C语言中使用头文件保存程序中用到的声明，例如函数声明、常量定义等，C++也是；
* 使用#include指令包含了头文件iostream；
* iostream是C++的标准输入/输出流，当在程序中使用cin或cout时，必须在头文件中包含这个流；
* 每条#include指令仅可以包含一个头文件；
* 在C++中，头文件不再以".h"结尾。以".h"结尾的头文件是C语言中常用的头文件；
* 常用的头文件有以下：
* 标准输入输出流：<iostream>;
* 标准文件流：<fstream>;
* 标准字符串处理函数：<string>;
* 标准数学函数：<cmath>;
*
* 除了系统提供的头文件，还可以自定义头文件，通常，使用尖括号在系统中提供的头文件，使用双引号引入自定义头文件；
* 使用尖括号时，C++编译器首先在C++系统设定的目录中寻找要包含的文件，如果没有，再到指令中指定的目录去寻找；
* 采用双引号时，C++编译器首先在用户当前目录下或指令中指定的目录下需要；
* 例如，要包含e:\myprog目录下的头文件ex1.h相应的语句如下:
* #include "e:\myprog\ex1.h"
*
* using namespace std;表示使用命名空间std；
* 一个大型程序通常由不同的模块构成，各个模块有可能是由不同的人开发，不同模块中出现的标识符之间可能有重名现象，
* 这就会引发错误。C++中为了避免名字定义冲突，特别引入了"命名空间"的定义，即namespace，命名空间是为了消除同名引起的歧义；
* 定义一个命名空间的语法如下：
* namespace 命名空间名
* {
*      命名空间内的各种声明（函数声明、类声明.......）
* }
* 命名空间也成为名字空间，这是C++的一种机制，使用关键字namespace把大量有逻辑联系的程序实体组合在一个标识符下；
* 例如：C++标准库中的所有标识符都定义在一个名为std的命名空间中。当程序使用标准程序库中的标识符时，如果没有语句
* "using namespace std;"，则cin和cout都没有定义，string也是如此，甚至endl也不能识别；
* using 命名空间名::标识符；
* using namespace 命名空间名；
* 前一种形式表示直接使用指定标识符；后一种表示使用指定命名空间内所有标识符；
*
* 三、强制类型转换运算符
* 当不同类型的量进行混合算术运算时，系统会自动进行合理的类型转换，也可以在程序中使用强制类型转换运算符
* static_cast或const_cast进行转换；
* static_cast用于将一种数据类型转换为另一种数据类型：
* static_cast<类型名>(表达式)
* 如下四种写法都是正确的：
*/

void cast_demo() {
    int oneInt1;
    double oneDouble;

    oneInt1 = static_cast<int>(oneDouble);
    oneInt1 = int(oneDouble);
    oneInt1 = (int) oneDouble;
    oneInt1 = oneDouble;//自动类型转换
}

/*
 * const_cast用于去除指针和引用的常量性，但不能去除变量的常量性。
 * const_cast<类型名>(表达式);
 * 这个运算符的功能是，将常量指针转换成非常量的指针，并且仍然指向原来的对象；
 * 或将常量引用转换成非常量的引用，并且仍然指向原来的对象；
 *
 * 见如下示例：
 */
using namespace std;

void const_cast_demo() {
    int a = 10;
    const int *p = &a; //不能使用常量指针p修改a的值
    const int ca = 30; //被const修饰
    int *q;
    cout << "a的地址为：\t\t" << &a << "\ta 的值为：\t" << a << endl;
    cout << "*p指向的地址为：\t" << p << "\t*p的值为：\t" << *p << endl;
    q = const_cast<int *>(p); //去除p的常量性赋给q，如果写q=p;会报错
    *q = 20; //如果写*p=20;是错误的
    cout << "a的地址为：\t\t" << &a << "\ta的值为：\t" << a << endl;
    cout << "*p指向的地址为：\t" << p << "\t*p的值为：\t" << *p << endl;
    cout << "*q指向的地址为：\t" << q << "\t*q的值为：\t" << *q << endl;
    cout << "分界线" << endl;
    p = &ca; //ca的值不能修改
    q = const_cast<int *>(p); //去除p的常量性赋给q，如果写q=p;会报错
    *q = 40; //*p=40;是错误的
    cout << "ca的地址为：\t\t" << &ca << "\tca的值为：\t" << ca << endl;
    cout << "*p指向的地址为：\t" << p << "\t*p的值为：\t" << *p << endl;
    cout << "*q指向的地址为：\t" << q << "\t*q的值为：\t" << *q << endl;
}

/*
 * 程序说明：其中定义了俩个指针，p是常量性的，q不是常量性的。如果将p赋值给q，会报错，正如程序组注释所标注的。
 * 使用强制类型转换后，赋值成功；并且可以使用指针q对其所指地址的内容进行修改。这是程序前半段的运行情况，"分界线"之前显示了运行结果；
 * 接下来，使用同样的操作，处理ca，变量ca有const属性，因此ca的值是不会被程序所改变的。即使将指向ca的指针p的const属性去掉，重新赋值给q，
 * 并通过q进行修改，将q所指地址的内容修改为另一个值，也不会改变ca的值。所以这里出现了变量ca地址和指针q指向地址相同，但值不同的现象。
 *
 * 四、函数参数的默认值
 * 在C++语言中，可以在声明函数时为形参指定默认值。当调用有默认参数值的函数时，调用语句可以不给出对应的实参，相当于调用该函数时，以
 * 默认值为参数。指定默认值时不仅可以用常数，还可以用任何有定义的表达式作为参数的默认值。但不允许是函数内定义的局部变量。
 *
 * 定义带有默认值的函数，见如下示例：
 */

void default_params_demo(int a = 11, int b = 22, int c = 33) {
    cout << "a=" << a << ",b=" << b << ",c=" << c << endl;
}

/*
 * 运行结果未达到预期，大致能猜到，可能是环境原因；
 *
 * 函数调用示例：
 * void defaultValue(int = 2,double = 3.0);
 * void defaultValue(int a,double b = 3.0);
 * void defaultValue(int a = 2, double b);
 * void func(int a,int b = 2,int c = 3);
 * void func(int a = 1,int b,int c = 3);
 * void func(int a = 1,int b = 2,int c)
 *
 * 第一组函数，前俩个是正确的，可以没有变量名。但如果给出默认值，必须按从右到左的次序依次给出，不能给出左侧参数的默认值而忽略右侧。
 * 第二组函数同理，只有第一个是正确的。
 *
 * 假设给出以下函数：
 * void func(int a,int b=2,int c=3);
 * 下列那些函数调用是正确的？
 * func(1,22,333); //正确，全参且类型都是匹配的
 * func();         //错误，参数a没有默认值，必须给出实参
 * func(10,20);    //正确，c采用默认值
 * func(5,,9);     //错误，调用时给出的实参应是连续排列的
 *
 * 调用示例(二)示例：
 * 假设给出如下函数及变量声明：
 * int Max(int m,int n);
 * int a,b;
 * void func(int x,int y=Max(a,b),int z=a-b){......};
 * 则下列函数调用中哪些正确？
 * func(4);
 * func(4,9);
 * func()的定义中使用表达式作为形参y和z的默认值，这些表达式在调用时都有结果，所以俩个调用是正确的。
 *
 * 函数参数的默认值可以写在声明函数的地方，也可以写在定义函数的地方，但不能俩个地方都写。
 *
 * 五、引用和函数参数的传递
 * 1.引用的定义
 * 引用相当于给变量起了个别名。变量对应与某个内存地址，如果给某个变量起了别名，相当于变量和这个引用都对应到同一个地址。
 * 程序中使用哪个名字都是可以的。在C++中，"引用"的定义格式如下：
 * 类型名 &引用名 = 同类型的某变量名；
 * 举例如下：
 * int oneInt;
 * int &aname = oneInt; //声明引用
 * 这样定义后，aname就是一个引用，它的类型是int &。声明引用后，系统并不为aname分配内存空间，aname与oneInt对应的是一个内存地址。
 * 对于类型T而言，类型为T &的引用和类型为T的变量是完全兼容的，可以互相赋值。例如，如果变量oneInt的值保存在0x5ffddc地址中，
 * 则&aname是0x5ffddc。如果"oneInt = 3"，那么执行下列语句时，会输出值3：
 * cout<<aname<<endl;
 * 声明引用aname时，变量oneInt必须进行了初始化。在C++98标准下，系统自动将oneInt初始化为0。另外，不能有空引用，即引用
 * 必须指向某个已存在的内存区域的首地址。也不能声明引用的引用，例如，这样的声明"int &b = &aname;"是错误的；
 * 同一个变量的引用可以有多个，例如，变量oneInt还可以有另一个引用bname。此时，即可以使用变量来进行引用初始化，也可以使用
 * 引用aname为另一个引用bname进行初始化；
 * 定义引用时，可以在定义的前面加const关键字，表明该引用是"常引用"，例如：
 * int oneInt;
 * const int &cname = oneInt;
 * 这两行定义了常引用，它的类型是const int &。
 *
 * 常引用和普通引用的区别在于：不能通过常引用去修改其引用的变量。在下面程序中，定义了普通引用ref和常引用refc，它们都是值为1的
 * 整形变量oneInt的引用。通过普通引用ref可以修改oneInt的值，但不能通过常引用refc改变oneInt的值。
 */

void const_and_normal_ref() {
    int oneInt = 1;
    int &ref = oneInt;                      //ref是oneInt的引用，ref等价于oneInt
    const int &refc = oneInt;               //定义常引用
    ref = 2;                                //修改ref也即修改了oneInt
    cout << "oneInt = " << oneInt << "," << "ref = " << ref << endl;    //输出oneInt=2，ref=2
    cout << "refc = " << refc << endl;      //输出refc=2
    oneInt = 3;                             //修改oneInt也即修改了ref
    cout << "ref = " << ref << endl;        //输出ref=3
    cout << "refc = " << refc << endl;      //输出refc=3
    int &ref2 = ref;                        //ref2和ref都是oneInt的引用
    cout << "ref2 = " << ref2 << endl;      //输出ref2=3
    //refc = 5;                             //错误，不能使用常引用对所引用的变量进行修改
}

/*
 * const T &和T &是不同的类型。当声明变量并进行初始化时，同类型之间进行初始化是允许的，不同类型之间进行初始化，有些情况是允许的。
 * 例如，使用T类型的变量或T &类型的引用，均可以初始化const T &类型的引用和T &类型的引用。
 * 但是，使用const T类型的常变量和const T &类型的常引用却不能直接用来初始化T &类型的引用。如果必须这样做，则需要强制转换。
 * 以整形类型为例，关于初始化的各种组合情况，参照如下示例：
 */

void ref_init_demo() {
    const int cInt = 30;
    int oneInt = 50;
    int &ref = oneInt;          //T& <- T
    const int &rc1 = cInt;      //CT& <- CT,CT&表示类型T的常引用
    const int &rc2 = oneInt;    //CT& <- T
    const int &rc3 = ref;       //CT& <- T&
    int dInt = ref;             //T <- T&
    int eInt = cInt;            //T <- CT, CT表示常量类型
    int fInt = rc1;             //T <- CT&
    const int gInt = oneInt;    //CT <- T
    int &ref1 = ref;            //T& <- T&
    const int hInt = ref;       //CT <- T&
    const int jInt = cInt;      //CT <- CT
    const int &mInt = rc1;      //CT& <- CT&
    const int nInt = rc2;       //CT <- CT&
    cout << "OK" << endl;
    int &r2 = (int &) rc1;      //T& <- CT& 需要强制类型转换
    int &r3 = (int &) cInt;     //T& <- CT 需要强制类型转换
}

/*
 * 其中，T表示类型，CT表示常量类型， T&表示类型T的引用，CT&表示类型T的常引用。
 * 以上列出了变量、变量引用、常变量及常引用之间的各种初始化情况，大多数都是允许的，只有最后俩种情况需要通过强制类型转换来初始化；
 *
 * 2.引用在函数中的使用
 * 在程序中，不仅可以定义变量的引用，还可以将引用用在函数中。引用即可以作为函数的参数使用，也可以作为函数的返回值使用。
 *
 * 在C++中，函数调用时参数的传递有俩种方式：传值和传引用。传值，实际上是传递对象的值。传引用，是传递对象的首地址。
 * 如果函数的形参不是引用，那么调用时实参传递给形参通常采用的是传值的方式，即将实参的值拷贝给形参。在函数执行过程中，都是对这个
 * 拷贝进行操作的，函数执行完毕返回后，形参的值并不拷贝回实参，也就是说函数内部对形参的改变不会影响到函数外实参的值。
 *
 * why? 调用一个函数时，他的形参及函数内部定义的局部变量被分配在称为栈的内存空间中。这与实参所在的空间不同。传值时，将实参的值
 * 拷贝到栈中对应的形参的地址中，函数内部对形参的操作，其实是对这个地址操作，而不是对实参所占用的地址进行操作的。函数执行完毕时，
 * 并不将这个地址中的值拷贝出去，所以实参的值不会收到影响。
 *
 * 如果函数的形参是引用，则调用时实参传递给形参采用的是传引用的方式。函数调用时，实参对象名传递给形参对象名，形参对象名就成为了
 * 实参对象名的别名，即形参是对应实参的引用，它们是等价的，代表同一个对象，也可以看作是将实参的地址传递给了形参。在函数内部
 * 对形参的操作，都是对这个地址的内容进行的，相当于对实参的值进行了操作。所以，实参的变化被保留了下来。
 *
 * 不同的参数传递方式，见如下示例：
 */

void SwapValue(int a, int b) {
    int tmp;
    tmp = a;
    a = b;
    b = tmp;
    cout << "在SwapValue()函数中：\t\ta = " << a << ",b = " << b << endl;
}

void SwapRef(int &a, int &b) {  //a、b值互换
    int tmp;
    tmp = a;
    a = b;
    b = tmp;
    cout << "在SwapRef()函数中：\t\ta = " << a << ",b = " << b << endl;

}

void SwapTest() {
    int a = 10, b = 20;
    cout << "数据交换前：\t\ta = " << a << ",b = " << b << endl << endl;
    SwapValue(a, b);
    cout << "调用SwapValue()后：\t\ta = " << a << ",b = " << b << endl << endl;
    SwapRef(a, b);
    cout << "调用SwapRef()后：\t\ta = " << a << ",b = " << b << endl << endl;
}

/*
 * 总结以下，在传值调用函数的情况下，形参是实参的副本，形参的改变不会影响到实参。但调用时生成临时变量完成值的复制，
 * 这需要一定的时间和空间。在传引用调用函数的情况下，形参的改变就意味着实参的改变。
 * 可以用const引用作为函数的参数，这样做，既可以避免赋值形参时所需要的开销，又能防止实参在函数执行过程中被改变。
 *
 * 引用还可以作为函数的返回值。变量是可以作为赋值语句的左值存在的，既然引用可以看作变量的别名，那么引用也可以作为赋值语句的左值，
 * 即可以放在赋值语号的左侧。
 *
 * 在赋值语句中，赋值号左侧的表达式称为左值，右侧的表达式称为右值。左值表达式即能出现在赋值号的左侧，也能出现在赋值号的右侧。
 * 变量、引用、指针都可以作为左值。例如，对于整形变量x和y，可以写x=3;和x=y;。对于整形指针（指向整形的指针，即int *p）,可以
 * 写"*p = &x;"和"*p = 5;"。
 *
 * 返回引用的函数格式如下：
 * 数据类型 & 函数名(参数列表)；
 *
 * 具体见如下示例：
 */
int &RefValueFunc(int &x) {
    return x;
}

void RefValueFuncTest() {
    int oneX = 10;
    int oneY = 20;
    RefValueFunc(oneX) = 30;            //返回值是引用，可以作为左值使用
    cout << "oneX = " << oneX << endl;     //输出oneX = 30
    RefValueFunc(oneY) = 40;
    cout << "oneY = " << oneY << endl;     //输出oneY = 40
}

/*
 * RefValueFunc()函数的返回值是一个引用，所以可以作为赋值语句的左值使用。
 * 函数的返回值还可以是指针，这样的函数称为指针函数，函数的格式如下：
 * 类型标识符 * 函数名(参数列表);
 *
 * 六、const与指针共同使用
 * 与C语音一样，C++也可以使用const限定访问权限，告诉编译器，它所修饰的量是不能改变的，也就是不能作为左值使用；
 * 程序中使用指针时，涉及的量有俩个：一个是指针本身，另一个是指针所指向的内容；
 * 当const与指针共同使用时，其确切的含义是什么？是说指针本身不能改变，即不能让其指向其他地址？
 * 还是指针所指向的内容不能改变？亦或是俩个含义多有？
 * 其实，当const与指针共同使用，其书写位置不同造成的语句语义也不同。
 *
 * const修饰指针变量时，基本含义如下：
 * 1)如果唯一的const位于符号*的左侧，表示指针所指数据是常量，数据不能通过本指针改变，但可以通过其他方式进行修改，
 * 指针本身是变量，可以指向其他的内存单元；
 * 2)如果唯一的const位于符号*右侧，表示指针本身是常量，不能让该指针指向其他内存地址，指针所指向的数据可以通过本指针修改；
 * 3)在符号*左右各有一个const时，表示指针和指针所指向数据都是常量，既不能让指针指向其他地址，也不能通过指针修改所指向的内容；
 *
 * 常量说明示例如下
 */

void const_and_zhizhen_demo() {
    int a1 = 3;                 //普通变量，a1 = 5是正确的
    const int a2 = a1;          //数据常量的，a2 = 5是错误的
    int *a3 = &a1;              //普通指针指向普通变量，*a3 = 6是正确的
    const int *a4 = &a1;        //数据是常量的，普通指针 *a4 = 5是错误的
    int *const a5 = &a1;        //指针是常量的，不能修改指针，但*a5 = 10是正确的
    int const *const a6 = &a1;  //数据是常量的，指针也是常量的
    const int *const a7 = &a1;  //数据是常量的，指针也是常量的
}

/*
 * const的修饰规则：const修饰其左侧的内容；如果const是本行第一个标识符，则它修饰其右侧的内容；
 *
 * 七、内联函数
 * 在程序中使用函数的目的之一是减少程序代码，提高开发效率；
 * 但是在调用函数时，需要保存主调函数的现场和返回地址，要在栈中为形参和局部变量分配存储空间，要实现实参与形参的参数传递，
 * 然后程序转移到被调函数的起始地址继续执行。被调函数执行结束后，要从栈中回收形参和局部变量占用的存储空间，要恢复主调函数
 * 的现场，取回返回地址，有返回值的要将返回值覆盖函数调用本身，最后在返回地址出开始继续执行。
 * 总之，调用函数时会带来程序运行时间上的开销，使得程序的执行效率降低。
 *
 * 如果一个函数的函数体较大，那么调用函数及返回时所付出的代驾，与代码共享所得到的回报相比，微不足道。
 * 但如果是只有很少几条语句的函数，这个函数调用产生的额外开销和函数本身执行的时间相比，就不能忽略了。
 * 特别是调用频繁时，函数调用导致的时间开销可能是程序运行明显变慢。
 *
 * 为了避免这种频繁的函数调用与返回，C++语言引入了内联函数的概念。使用内联函数，编译器在编译时并不生成函数调用，
 * 而是将程序中出现的每一个内联函数的调用表达式直接用该内联函数的函数体进行替换，就像整个函数体在调用处被重写了一遍一样。
 * 很显然，使用内联函数会使最终可可执行程序的体积增大，这是以空间消耗节省时间开销。
 *
 * 内联函数应该定义在前，调用在后，定义时值需要在函数头返回值类型的前面加上关键字inline。格式如下：
 * inline 返回值类型 函数名(形参表){
 *      函数体
 * }
 * 如果仅在声明函数的原型时加上关键字inline，并不能达到内联效果。
 *
 * 内联函数主要应用于代码量少的函数，编译时，编译程序将整个函数体的代码复制到调用该函数的位置，而不会编译成函数调用的指令。
 * 也就是说，内联函数不是在调用时发生控制转换，而是在编译时将函数体嵌入到每一个调用处。
 *
 * 对于代码量较大的函数，如果将其定义为内联函数，则增加的程序长度对时空效率的不利影响，有可能早已抵消了使用内联函数避免
 * 函数调用所带来的速度改善。所以，强调，内联函数一般来说仅适用于只有几条语句的小函数。
 *
 * 如果函数体中有循环语句和switch语句则通常不定义为内联函数。事实上，如果将一个复杂的函数定义为内联函数，大多数编译器
 * 会自动将其作为普通函数处理。因此，在函数定义上加上inline关键字，仅仅是提示编译器，程序员希望函数是内联函数。
 * 编译器根据自己的处理方式，可能忽略这一提示，而生成真正的函数调用。
 *
 * 八、函数的重载
 * 程序中经常会出现对不同类型的量进行同类操作的情况，例如，找出俩个数值之间的较大着并返回。这俩个数值可能都是整数，也可能都是浮点数，
 * 还可能是俩个字符串。当然对于字符串，可以按照字典序定义字符串的"大小"，示例如下：
 */

int biggerInt(int x, int y) {
    if (x > y) return x;
    else return y;
}

float biggerFloat(float x, float y) {
    if (x > y) return x;
    else return y;
}

double biggerDouble(double x, double y) {
    if (x > y) return x;
    else return y;
}

/*
 * 为了区分各个函数，需要命名不同的函数名，调用时也要对号入座。
 * 面相对象程序设计语音的特点之一就是允许函数的重载，C++也不例外。
 * 所谓的函数重载，是指在程序的同一范围内声明几个功能类似的同名函数，例如，在一个类中声明3个求俩者中较大值的同名函数，
 * 使用同一个函数名作为功能一样的函数的函数名。示例如下：
 *
 */
int bigger(int x, int y) {
    if (x > y) return x;
    else return y;
}

float bigger(float x, float y) {
    if (x > y) return x;
    else return y;
}

double bigger(double x, double y) {
    if (x > y) return x;
    else return y;
}

/*
 * 有了函数的重载，在编写C++时，可以完成类似功能的不同函数统一命名，减少了命名空间的浪费；
 * 函数名加上参数表称为函数的签名，也就是说，重载函数的签名是不同的；
 * 实现函数的重载必须满足下列条件之一：
 * 1)参数表中对应参数类型不同；
 * 2)参数表中参数个数不同；
 * 如果俩个函数仅仅返回值类型不同，那么不是重载，是重复定义会报错；
 * 另外，采用引用参数也不能区分函数。
 * void print(double);
 * void print(double&); //错误，是重复定义
 * 另外，调用时实参和形参类型不完全匹配，但存在赋值兼容情况，编译器会进行必要的类型提升；（int和double都可以自动转换为double类型）
 *
 * 需要注意的是，在有函数重载，当进行类型转换时，可能会出现多个函数都匹配的情况，也就是函数调用出现了二义性。此时编译器无法确定
 * 哪一个才是真正需要调用的，所以会报错。因为将double取整或将整型提升为浮点型都是C++允许的。
 *
 * 在俩个函数同名，参数个数不同，但是参数多的那个函数有默认值的情况下，也会引发二义性：
 * int sum(int a,int b,int c=0);
 * int sum(int a,int b)
 * 调用sum(1,2)同样会产生编译错误。
 *
 * 九、指针和动态内存分配
 * 指针变量中保存的是一个地址，有时也称为指针指向一个地址。
 * 若有以下定义
 * int a = 100 , *p = &a;
 * 则下列选项，表述错误的是(  D  )
 * A.声明变量p，其中*表示p是一个指针变量；
 * B.变量p经初始化，获得变量a的地址；
 * C.变量p只可以指向一个整形变量；
 * D.变量p的值是100；
 * 分析，指针p指向整型变量a，p中保存a的地址，而不是值100，p指向的值是100。地址与地址中的值不要混淆。
 *
 * 数组的长度是声明数组是指定的，在整个程序运行过程中通常是不变的。C++语言不允许定义元素个数不确定的数组；
 * int n;
 * int a[n]; //在有些编译环境下，是不被允许的。
 * 在程序设计中，通常会遇到根据待处理的数据量来确定数组的大小的情况。如果没有办法提前得知数据量的大小，往往会分配一个尽可能大的数组。
 * 一方面，如果数据量并没有那么多，则可能会造成空间浪费；另一方面，如数据量超过了预估，则会造成数组容量不足；
 *
 * C++语言提供了一种"动态内存分配"机制，在程序运行期间，根据实际需要，临时分配一段内存空间用于存储数据。与声明数组时就需要
 * 指定数组大小的内存分配方法不同，这种内存分配是在程序运行期间进行的，故称为"动态内存分配"。相对地，编译时确定数组空间大小
 * 的方式称为"静态内存分配"。
 *
 * 在C++中，使用new运算符实现动态内存分配。例如：
 * p = new T;
 * 其中T是任意类型名，p是类型为T*的指针。这样的语句会动态分配出一片大小为sizeof(T)字节的内存空间，并且将该内存空间的起始地址
 * 赋值给指针p。例如：
 * int *p;
 * p = new int;
 * *p = 5;
 * 第2行语句动态分配了有4个字节大小的内存空间，p指向这个空间的首地址，之后通过指针p可以读写该内存空间，第3行语句是向这个空间中
 * 存入数组5；
 *
 * 使用new运算符还可以动态分配一个任意大小的数据：
 * p = new T[N];
 * 其中T是任意类型名，p是类型为T*的指针，N代表数组"元素个数"，可以是任何值为正整数的表达式。
 * int *pArray;                 //指向数组的指针
 * int i = 5;
 * pArray = new int[i*20];      //分配了100个元素的整型数组
 * pArray[0] = 20;              //数组第一个值
 * pArray[99] = 30;             //数组最后一个值
 * 数组下标从0开始，含n个元素的数组下标范围是0~n-1。超出这个范围会导致数组下标越界。
 *
 * 使用new运算符动态申请的内存空间，需要在使用完毕释放。C++提供了delete运算符，用来释放动态分配的内存空间：
 * delete 指针;
 * delete运算符后面的指针必须是指向动态分配内存的内存空间，否则运行时出错：
 * int oneInt = 6;
 * int *p = &oneInt;
 * cout<<*p<<endl;
 * delete p;            //出错，p是引用，不是动态分配的
 * int *q = new int;
 * *q = 8;
 * cout<<*q<<endl;
 * delete q;            //正确，q指向动态分配的空间
 *
 * 如果使用new运算符分配了一个数组，那么释放该数组时，语句如下：
 * delete []指针;
 * 如果用"delete 指针"来释放数组，虽然编译没问题，但实际上会导致动态内存分配的数组没有完全被释放。
 *
 * 使用new运算符分配的内存空间，一定要用delete运算符释放。否则，即使程序运行结束，这部分内存空间仍然不会被操作系统回收，
 * 从而成为被白白浪费掉的内存垃圾，这种现象称为"内存泄露"。如果一直不停的进行动态内存分配，而不进行释放，会导致可用内存越来越小，
 * 操作系统运行速度缓慢，严重时必须重启计算机才能恢复。
 *
 * 使用指针时，必须要严谨。当使用delete释放掉指针所指向的空间后，如果再通过指针访问这个空间，也得不到想要的结果。
 *
 *
 * 十、用string对象处理字符串
 * C++标准库提供了string数据类型，专门用来处理字符串。string是一个类，这个类型的变量称为"string对象"。一个string对象可以用来
 * 保存一个具体的字符串。
 *
 * string对象与基本类型的变量有不同之处。例如，一个整数可以直接保存在一个整形变量中。而string对象所代表的字符串保存在内存中，
 * 这段内存的首地址保存在string对象中。也就是说并不是字符串本身保存在string对象中。为了叙述方便，提到字符串对象时，通常不去区分字符串
 * 本身或是保存字符串的地址，"字符串对象中的字符串"就是指"字符串对象所保存的地址中的字符串"。
 *
 * 不论字符串的长度如何，在同一种系统下，保存字符串的内存首地址都是一样长的，即一个string对象的大小是固定的。表达式sizeof(string)
 * 代表string对象的大小，它的值可能随着编译器或操作系统的不同而不同。例如，sizeof(string)在32位的Dev C++中是4，64位Dev C++中是8。
 *
 * 要在程序中使用string对象，必须在程序头中包含头文件string，即在程序最前面要加上如下语句：
 * #include <string>
 * 使用string对象处理字符串时，要比使用字符数组的方法更简洁，不易出错。
 *
 * 1.声明一个string对象
 * 与声明普通变量类似：
 * string 变量名;
 * 在声明string变量通同时，也可以进行初始化。即可以使用字符串常量初始化，也可以使用另一个字符串变量初始化。
 * 没有初始化的字符串变量的值即是空串,即""。注意，字符串常量使用双引号括起来。例如：
 * string str1;                 //声明string对象，值为空
 * string city = "Beijing";     //声明string对象city，并使用字符串常量进行初始化
 * string str2 = city;          //声明string对象str2，并使用字符串变量进行初始化
 *
 * //还可以使用字符数组进行初始化
 * char name[]="C++"
 * string str3 = name;
 *
 * 还可以声明一个strinig对象数组，即数组中每个元素都是字符串，例如：
 * string citys[] = {"Beijing","Shanghai","Tianjin"};
 * cout<<sizeof(citys)/sizeof(string)<<endl;        //输出数组元素个数
 *
 * 第二行输出数组元素个数。citys是string类型数组，siezeof(ciitys)是整个数组占用的空间大小，sizeof(string)是每个string对象的大小
 * (随系统或编译器决定的固定值)，所以sizeof(citys)/sizeof(string)表示的数组元素的个数。
 * 如下所示：
 */
#include <string>

void getArraySize() {
    string citys[] = {"beijing", "shanghai", "chongqing", "xuchang"};
    cout << sizeof(citys) << endl;
    cout << sizeof(string) << endl;
    cout << sizeof(citys) / sizeof(string) << endl;
}

/*
 * 2.string对象操作
 * string对象可以比较大小，通过字典序进行的，而是大小写相关的。"Zbc"<"abc";小写ASCII码更大。
 * 还可以用"+"进行连接。
 * 如下所示：
 */

void stringOp() {
    string s1, s2;
    s1 = "C++程序";
    s2 = s1;
    string s3;
    cout << "s3 = " << s3 << endl;//输出 s3=
    s3 = s1 + s2;
    cout << s1 + s2 << endl;//输出C++程序 C++程序
    cout << "s3 = " << s3 << endl;//输出 s3=C++程序C++程序
    s3 += "de";
    cout << "s3 = " << s3 << endl;//输出 $3=C4+程序C4+程序de

    bool b = s1 < s3;//b为 true
    cout << "bool = " << b << endl;//输出 bool = 1
    char c = s1[2];//c 为4，下标从0开始计算
    cout << "c = " << c << endl;//输出c=+
    cout << s1[3] << endl;//输出+
    char arrstr[] = "Hello";
    s3 = s1 + arrstr;
    cout << s3 << endl;// 输出C++程序 Hello
}

/*
 * 3.string对象用法示例
 * string类提供了一些成员函数，可以用来方便的实现一些功能，如查找子串等。这些成员函数的调用方法是"string对象名.成员函数名(参数)"；
 * 成员函数是这个类提供的一些方法；
 * const char *c_str() const;                       返回一个指向字符串的指，字符串内容与string串相同，用于将string转换为const char *
 * int size() const;                                返回当前字符串大小
 * int length() const;                              返回当前字符长度
 * bool empty() const;                              判断当前字符串是否为空
 * size_type find(const char *str,size_type index); 返回str在字符串中第一次出现的位置，从index开始查找，如果没有返回-1
 * size_type find(char ch, size_type index);        返回ch字符在字符串中第一次出现的位置，从index开始查找，如果没有返回-1
 * string &insert(int p, const string &s);          在p位置插入字符串s
 * string &append(const char *s);                   将字符串s连接到当前字符串结尾处
 * string substr(int pos=0, int n=npos) const;      返回从pos开始的n个字符组成的字符串
 *
 * 如下所示：
 */

void stringMemberFunc() {
    string str;                 //未初始化，空串
    if (str.empty()) cout << "str is NULL." << "length() = " << str.length() << endl;
    else cout << "str is not NULL." << endl;

    str.append("abcdefg");
    cout << "str is " << str << ", size() = " << str.size() << endl;

    const char *p = str.c_str();
    cout << "p = " << p << endl;


    cout << "find: " << str.find("de", 0) << endl;      //查找成功，3
    cout << "find: " << str.find("de", 4) << endl;      //查找失败

    string str1 = str.insert(4, "1234");
    cout << str1 << endl;
}

/*
 * 程序说明：字符串str在赋值前是空串，空串长度为0。函数c_str()将字符串str转换为const char *，赋值给指针p。
 * find()函数是重载函数，含多个参数形式。
 *
 */
void stringMemberFunc2() {
    string s1 = "C++";
    string s2 = "程序设计";
    string s3 = s1 + s2;
    string s4;
    s4 = s1.append(s2);
    if (s3 == s4) cout << "结果相同" << endl;
    else cout << "结果不同" << endl;
    int size = s1.size();
    int length = s1.length();
    cout << "size = " << size << "\t,length = " << length << endl;
    s1[0] = 'J';
    cout << "s1 = " << s1 << endl;
    string s5 = s1.substr(3, 4);
    cout << "s5 = " << s5 << endl;
    char str[20];
    strcpy(str, s5.c_str());
    cout << "str = " << str << endl;
    cout << "s1 = " << s1 << ", s2 = " << s2 << endl;
    s1.swap(s2);
    cout << "s1 = " << s1 << ", s2 = " << s2 << endl;
    cout << "str = " << str << endl;
    cout << "s2 = " << s2 << endl;
    cout << s2.find(str) << endl;
}

/*
 * 程序说明：用到strcpy()函数，它包含在头文件cstring中，所以程序中要使用#include <cstring>。连接俩个字符串即可以通过运算符"+"实现，
 * 也可以使用函数append()实现。函数s1.size()与s1.length()都是返回字符串s1的长度，注意，每个汉字的长度为2。
 * s1.substr(3,4)返回字符串s1中从下标3开始、长度为4的子串。函数的第一个参数表示起始未知下标，第二个参数表示子串的长度。
 * 如果从起始位置开始，字符串中剩余子串长度小于第二个参数值，则返回一直到到原串尾的子串。
 * strcpy(str,s5.c_str())将s5的内容赋值到str中。
 *
 * Section 3 C++语言的程序结构
 *
 * C++程序以.cpp作为文件扩展名，文件中包含若干类，和若干个函数。程序中必须有且仅有一个主函数main()，这是程序执行总入口。
 * 主函数也称为主程序。程序从主程序开始处执行，按照其控制流程，一直执行到结束。
 * 程序结束一般遇到以下俩种情况之一：
 * 1)在主函数中遇到return语句；
 * 2)执行到主函数最后的括号}；
 * 主函数中可以调用程序中定义的其他函数，但其他函数不能调用主函数。主函数仅是系统为执行程序时所有调用的。
 * C++程序中，仍沿用C语言的注释风格：
 * 1)从/*开始到*\/结束
 * 2)从//直到行尾
 */

/*
 * 一下程序输出结果是6，请补全
 */

void test() {
    const int x = 5, y = 6;
    const int *p = &x;
    //
    p = &y;
    //
    cout << *p << endl;
}

/*
 * 键盘录入一维字符串数组，在输入字符串前，先输入n值。要求数组需要动态申请空间，并在程序结束释放。
 */
void testArray() {
    int n;
    cout << "请输入字符串个数n: ";
    cin >> n;

    // 动态申请空间
    char **strArr = new char *[n];
    for (int i = 0; i < n; i++) {
        strArr[i] = new char[100]; // 假设每个字符串最长为100
    }

    // 录入字符串
    for (int i = 0; i < n; i++) {
        cout << "请输入第" << i + 1 << "个字符串：";
        cin >> strArr[i];
    }

    // 输出字符串
    cout << "输入的字符串数组为：" << endl;
    for (int i = 0; i < n; i++) {
        cout << strArr[i] << endl;
    }

    // 释放动态申请的空间
    for (int i = 0; i < n; i++) {
        delete[] strArr[i];
    }
    delete[] strArr;

}