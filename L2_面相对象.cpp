//
// Created by admin on 2023/2/27.
//

#include "L2_面相对象.h"
#include <iostream>
using namespace std;

int main() {
    cout << "123xxx" << endl;
    return 0;
}

/*
 * Target:
 * 1.了解结构化程序设计的基本方法及其局限性；
 * 2.理解面相对象程序设计的概念和特点，并与结构化程序设计进行对比，理解抽象、封装、继承和多态的含义；
 * 3.掌握类定义的方法，了解成员变量、成员函数的概念；
 * 4.了解类中定义各个访问范围说明符的含义；
 * 5.理解对象的概念；
 * 6.掌握使用指针、引用访问类成员的方法；
 *
 * --------------------------------------------------------------------------------------------------
 *
 * Section 1 结构化程序设计
 * 结构化程序设计也称为面相过程的设计方法，最早是由E.W.Dijkstra在1965年提出，这个时期程序设计语言以Pascal和C为代表。
 * 强调数据类型和程序结构，注重程序的易读性、可靠性以及可维护性。
 *
 * 在结构化程序设计中采用自顶向下，逐步求精及模块化的思想，将复杂的大问题层层分解为许多简单的小问题。也就是说，将问题看作
 * 是一系列需要完成的任务，使用函数来完成这些任务。把逻辑功能完全独立或相对独立的程序部分设计成函数，每个函数要完成的功能不多
 * 且明确。所以解决问题的焦点集中于函数的设计与相互的调用上，程序员要考虑的是如何将整个程序分解成一个一个函数，哪些函数之间
 * 要互相调用，以及每个函数内部将如何实现。程序设计的过程基本上就是编写函数的过程。
 *
 * 使用含有顺序、选择、循环三种基本控制结构来构造程序，程序以控制结构为单位，只有一个入口和一个出口，基于控制结构可以从前往后的
 * 阅读程序，结构化程序设计主要强调的是程序的易读性。
 *
 * 有一个著名的公式体现了结构化程序设计的基本思想：数据结构+算法=程序。
 * 公式中强调了算法施加于数据结构上的操作，同时又把算法和数据结构分离。数据结构和变量相对应，算法和函数相对应。
 * 原则上，只要类型条件满足，任何函数都可以对任何变量进行操作。在这种机制下，模块之间的耦合度高，导致函数之间的调用关系错综复杂，
 * 没有有效的手段控制函数可以施加操作的范围。
 *
 * 另外，对变量进行操作的函数可能散步在程序的各处。如果变量的类型有所变化，则相关的所有函数都要修改，这个工作量是巨大的。所以
 * 采用面相过程方法开发的程序的维护开销较大。修改程序尚且如此，程序功能拓展或版本升级时，情况更加严重。
 * 结构化程序设计没有"封装"和"隐藏"的概念，要访问某个变量时可以直接访问，当该变量的定义有改动时，或是添加了新的变量及功能时，
 * 就要把所有于此相关的函数找出来修改。
 *
 * 总之，结构化设计方式实现的程序在代码规模庞大时，会变得难以理解、难以扩充、难以差错和难以复用。这种情况下，面相对象的程序设计方法就产生了。
 *
 * Section 2 面相对象程序设计的概念和特点
 * 它继承了结构化程序设计的优点，同时又比较有效的改善了结构化程序设计的不足。面相对象的概念和应用已不再局限于程序设计和软件开发，
 * 扩展到很宽的范围，如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、人工智能领域。
 * 所谓面相对象的程序设计方法，就是使分析、设计和实现一个系统的方法尽可能地接近人们认知一个系统的方法。
 * 通常包括3个方面：面相对象的分析、面相对象的设计和面相对象的程序设计。
 *
 * 面相对象技术把问题看成是相互作用的事物的集合，也就是对象的集合。对象具有俩个特性：一是状态；二是行为。
 * 状态是指对象本身的信息，也称为属性；行为是对对象的操作。
 * 通过对事物的抽象找出同一类对象的共同属性（静态特征）和行为（动态特征），从而得到类的概念。
 * 对象是类的一个具象，类是对象的一个抽象。
 * 在面相对象技术中，属性表现为数据，用属性值来描述对象的状态，而把对对象的操作定义为函数。
 * 这样对象就是数据加函数。
 *
 * 面相对象程序设计的特点：抽象、封装、继承、多态。
 * 将同一类事物的共同特点概括出来，这个过程就叫做"抽象"。
 * C++中使用对象名、属性和操作三要素来描述对象。描述属性的数据称为成员变量或数据程序，函数称为成员函数。对象
 * 由一组属性和对这组属性进行操作的成员函数构成。
 * 类模型结构和对象结构相似，都含有属性和操作。不同的是，对象结构图有对象名而没有类名，类模型结构图中有类名而没有对象名。
 *
 * 将数据和对该数据进行合法操作的函数"捆绑"在一起作为一个类的定义。对象被说明为具有一个给定类类型的变量。每个给定类的对象
 * 包含了这个类所规定的若干私有成员、公有成员及保护成员。这个过程就叫做"封装"。封装将对象属性和操作结合在一起，构成独立的单元。
 * 对象的内部信息是可以对外隐蔽的，能合理安排数据的可访问范围，减少耦合度，从而提高代码扩充、提高复用性。
 *
 * "继承"就是编写一个新类，以现有类作为基础，使得新类从现有类派生而来，从而达到代码扩展和复用的目的。
 * 通过继承和复用可以更有效的组织程序结构。
 * 派生类能够继承基类定义的成员，继承会构成一个继承层次，其中有一个类称为根，其他类直接或间接继承根类。
 *
 * 在C++中，通过基类的引用（或指针）调用虚函数时，发生动态绑定。引用（或指针）即可以指向基类对象也可以指向派生类对象，
 * 这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的。
 * 通过动态绑定，能够编写程序来使用继承层次中任意类型的对象，而不必关系对象的具体类型。使用这些类的程序也不必区分函数
 * 是在基类还是在派生类中定义的。由此可得"多态"的概念。
 *
 * 多态是指不同种类的对象都具有名称相同的行为，而具体行为的实现方式有所不同。
 * 在C++中，多态性仅有于通过继承而相关联的引用和指针，因此通过继承而相关联的类型称为多态类型。
 *
 * 继承性和多态性的组合，可以轻易的生成一系列虽然类似但独一无二的对象。由于继承性，这些对象可以共享许多相似的特征。
 * 由于多态性，一个对象可以有独特的表现形式，而另一个对象有另一种表现形式。
 *
 * Section 3 类
 * 在C++中基本数据类型的变量也是对象，包括bool、char、int、float、double等。
 *
 * 面相对象方法中的类，是对具有相同属性和行为的同一类对象的抽象描述，其内部包括属性（本类的成员变量）和行为（本类的成员函数）俩主要部分。
 * 即类以数据为中心，把相关的一批函数组成为一体。
 * 在C++中，类定义的一般格式如下：
 * class 类名{
 *      访问范围说明符:
 *          成员变量1
 *          成员变量2
 *          ...
 *          成员函数声明1
 *          成员函数声明2
 *          ..
 *      访问范围说明符:
 *          更多的成员变量
 *          更多的成员函数
 *          ...
 * };
 *
 * 类以关键字class开始，后面是类名。访问范围说明符有3种：public(公有)、private(私有)和protected(保护)。
 *
 * 定义类是系统并不为类分配存储空间，而只是把类看作是一种模板和样板。或者说类可以看作是用户自定义的一种数据类型。
 * 在C++98标准下，类中的任何成员不能使用auto、extern和register关键字进行修饰。
 * 类中的成员变量不能在声明时进行初始化，也就是说，不能在类体内声明成员变量的同时给他赋初值。类中静态成员变量除外。
 *
 * 如果成员变量是私有的，那么在类外不可访问，所以通常在类中会为每个成员变量定义一对访问函数，一个用来设置值称为设置函数，
 * 另一个用来获取值称为获取函数。
 *
 * 类中的成员按功能划分，包括成员变量和成员函数；按访问权限划分，包括公有成员、私有成员和保护成员。
 *
 * 在C++中还可以定义不是任何类的成员的函数，这样的函数称为"全局函数"。
 *
 * 成员函数即可以在类体内定义，也可以在类体外定义。如果成员函数定义在类体内部，则默认是内联函数。也可以在类体内部声明函数，
 * 并加上inline关键字，然后在类体外给出函数定义，这也的函数也是内联函数。
 *
 * 如果成员函数定义在类体外，则类体内必须要有函数原型，类体外函数定义的前面必须用"类名::"来限定，格式如下：
 * 返回值类型 类名::成员函数名(参数列表){
 *      成员函数的函数体
 * }
 * 类名是成员函数所属类的名字，符号::是类作用域运算符，表明它后面的成员函数是属于类名标识的这个类的。
 * 类可以定义一个空类，什么成员都没有。
 *
 * Section 4 类剖析
 * 一个完整的C++程序包括以下几部分：
 * +一个主函数，可以调用其他函数，但不能被调用，也称为主程序；
 * +用户定义的任意多个的类及全局函数；
 * +全局说明。在所有函数和类定义之外的变量说明及函数原型；
 * +注释；
 * +头文件；
 *
 * .cpp是源程序文件；.h是头文件。
 *
 * 对象是类的实例。
 * 定义一个普通对象，即类变量的基本方法有俩种。
 * 方法一的基本格式如下：
 * 类名 对象名;
 * 或是
 * 类名 对象名(参数);
 * 或是
 * 类名 对象名 = 类名(参数);
 * 可以扩展为多个对象：
 * 类名 对象名1, 对象名2...';
 * 或是
 * 类名 对象名1(参数1), 对象名2(参数2)...;
 *
 * 此处"对象名"的命名规则和普通变量相同。创建对象时是否带有参数，要依赖类中构造函数的形式。创建对象后，
 * C++会为它分配相应的空间，用来存储对象所有的成员变量，而类中定义的成员函数则被分配到存储空间的一个公有区域，由该类的所有对象共享。
 * 方法二的基本格式如下：
 * 类名 *对象指针名 = new 类名;
 * 或是
 * 类名 *对象指针名 = new 类名();
 * 或是
 * 类名 *对象指针名 = new 类名(参数);
 *
 * 用new创建对象时返回的是一个对象指针，这个指针指向本类刚创建的这个对象。C++分配给指针的仅仅是存储指针值的空间，而对象所
 * 占用的空间分配在堆上，使用new创建的对象，必须用delete来撤销。
 *
 * 使用new 类名();创建对象时，调用无参构造函数，如果这个构造函数由编译器为类提供的，则对类中的成员变量进行初始化，如果不带()则不初始化。
 *
 * 与基本数据类型一样，还可以声明对象的引用、对象的指针及对象的数组。
 * 例如：
 * C a1,b1;         //定义了C类的对象a1和b1
 * C *p = &a1;      //定义了指向对象a1的C类类型的指针p
 * C &R = b1;       //定义了C类类型对象b1的引用R
 * C A[3];          //定义了C类类型对象的数组A，含3个元素
 *
 * 程序运行中，创建对象就是为对象分配内存，此时使用类作为模板，也就是按照类定义中声明的成员变量为对象分配内存。
 *
 * 示例：
 * 下列关于类和对象的说法中，正确的是(D)
 * A.编译器为每个类和类的对象分配内存；
 * B.类的对象具有成员函数的副本；
 * C.类的成员函数由类来调用；
 * D.编译器为每个对象的成员变量分配内存；
 *
 * 分析：选项A中，类并不占用空间，占用空间的是类的对象；
 * 选项B中，定义类后，不是每创建一个对象，就为成员函数分配存储的空间。实例化对象时，只会分配成员变量的空间，
 * 而不会分配成员函数的空间；
 * 选项C中，类的成员函数 不一定 是由类来调用的，普通成员函数由类的对象调用。类的静态成员函数由类来调用；
 *
 * Section 5 访问对象的成员
 * 1.使用对象访问成员变量/成员函数
 * 对象名.成员变量名
 * 对象名.成员函数名(参数表)
 * 2.使用指针访问
 * 如果使用指针来访问，则点运算符.换为箭头运算符->，即使用"指针->成员名"。
 * 3.使用引用访问
 * 引用就是对象的别名，使用点运算符即可，即"引用名.成员名"。
 *
 * Section 6 类成员的可访问范围
 * public 公有的，程序的任何地方都可以;
 * private 私有的，本类内部使用;
 * protected 保护的，本类及子类中访问;
 * 没有访问修饰符默认是私有的；
 *
 * 设置私有成员的机制叫做"隐藏"。隐藏的目的就是强制对私有成员的访问一定要通过公有成员函数进行。这样做的好处就是，如果
 * 以后修改了成员变量的类型等属性，只需要更改成员函数即可，否则，所有直接访问成员变量的语句都需要修改。
 *
 * Section 7 标识符的作用域和可见性
 * 标识符随处可见，作用域是指标识符的有效范围，可见性是指程序哪个区域可以使用。这两个区域可能是不完全重合的。
 *
 * 1.函数原型作用域
 * double area(double radius);
 * 标识符radius的作用范围仅在area的形参列表中有效，所以函数声明往往仅写行参的类型。
 * 2.局部作用域
 * 程序中相匹配的一对大括号括起来的一段程序称为块。作用域局限在块内的称为局部作用域。
 * 例如，在函数定义中，形参列表中的形参作用域，从声明处开始，到整个函数体结束为止。
 * 3.类作用域
 * 类可以看作一组有名字的成员的集合，类X的成员m具有类作用域，对m的访问方式有三种：
 * 1)如果类X的成员函数中没有同名的局部作用域标识符，那么m在该函数内可直接访问；
 * 2)x.m或X::m，正是访问对象成员的基本方法；
 * 3)在类外，可以通过prt->m，其中ptr是指向类X的一个对象的指针；
 * 4.命名空间作用域
 * 一个大型程序可能由不同模块组成，不同模块中类和函数之间可能发生重名，命名空间就是为了消除同名引起的歧义的。
 * 定义命名空间格式如下：
 * namespace 命名空间名{
 *      命名空间内各种声明(函数声明、类声明....)
 * }
 * 使用格式如下：
 * 命名空间名::标志符名
 *
 * 具有命名空间作用域的变量也称为全局变量。
 *
 * 如果存在俩个或多个具有包含关系的作用域，外层声明了一个标识符，而内层没有，可那么外层标识符在内层仍然可见；
 * 如果在内存声明了同名标识符，则外层标识符在内层不可见，这种机制称为 隐藏规则；
 *
 *
 */
